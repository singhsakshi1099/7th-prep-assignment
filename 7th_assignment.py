# -*- coding: utf-8 -*-
"""7th assignment

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_g1H3OfDbbhugB_2hb47hGkUAXIcb4H7
"""

#first solution
def is_isomorphic(s, t):
    if len(s) != len(t):
        return False

    char_map = {}
    mapped_chars = set()

    for i in range(len(s)):
        char_s, char_t = s[i], t[i]

        if char_s in char_map:
            if char_map[char_s] != char_t:
                return False
        else:
            if char_t in mapped_chars:
                return False
            char_map[char_s] = char_t
            mapped_chars.add(char_t)

    return True

#second solution
def is_strobogrammatic(num):
    strobogrammatic_map = {
        '0': '0',
        '1': '1',
        '6': '9',
        '8': '8',
        '9': '6'
    }

    left, right = 0, len(num) - 1

    while left <= right:
        if num[left] not in strobogrammatic_map or num[right] not in strobogrammatic_map:
            return False

        if strobogrammatic_map[num[left]] != num[right]:
            return False

        left += 1
        right -= 1

    return True

#third solution
def addStrings(num1, num2):
    # Reverse the input strings for easier digit access
    num1 = num1[::-1]
    num2 = num2[::-1]

    # Initialize variables for the result and carry
    result = []
    carry = 0

    # Perform digit-by-digit addition
    i = 0
    while i < len(num1) or i < len(num2):
        digit1 = int(num1[i]) if i < len(num1) else 0
        digit2 = int(num2[i]) if i < len(num2) else 0

        # Compute the sum and carry
        digit_sum = digit1 + digit2 + carry
        digit = digit_sum % 10
        carry = digit_sum // 10

        # Add the digit to the result
        result.append(str(digit))

        i += 1

    # Add the final carry if it exists
    if carry > 0:
        result.append(str(carry))

    # Reverse the result and return it as a string
    return ''.join(result[::-1])

#forth solution
def reverseWords(s):
    words = s.split()  # Split the string into words
    reversed_words = [word[::-1] for word in words]  # Reverse each word
    return ' '.join(reversed_words)  # Join the reversed words back together with whitespace

#fifth solution
def reverseStr(s, k):
    n = len(s)
    result = list(s)  # Convert the string to a list of characters for easy modification

    for i in range(0, n, 2 * k):
        start = i
        end = min(i + k, n)  # Determine the end index for reversing

        # Reverse the first k characters
        result[start:end] = result[start:end][::-1]

    return ''.join(result)  # Join the modified list of characters back into a string

#sixth solution
def rotateString(s, goal):
    # Check if the lengths of s and goal are equal
    if len(s) != len(goal):
        return False

    # Concatenate s with itself
    rotated = s + s

    # Check if goal is a substring of the rotated string
    if goal in rotated:
        return True

    return False

#seventh solution
def backspaceCompare(s, t):
    def process_string(string):
        stack = []
        for char in string:
            if char != '#':
                stack.append(char)
            elif stack:
                stack.pop()
        return ''.join(stack)

    return process_string(s) == process_string(t)

#eighth solution
def checkStraightLine(coordinates):
    if len(coordinates) <= 2:
        return True

    # Calculate the slope between the first two points
    x0, y0 = coordinates[0]
    x1, y1 = coordinates[1]
    slope = (y1 - y0) / (x1 - x0) if x1 - x0 != 0 else float('inf')

    # Check if the slopes between consecutive points are equal
    for i in range(2, len(coordinates)):
        xi, yi = coordinates[i]
        if x1 - x0 == 0:
            if (yi - y1) / (xi - x1) != slope:
                return False
        else:
            if (yi - y1) / (xi - x1) != slope:
                return False

    return True